const express = require('express');
const { getConnection } = require('../config/database');
const router = express.Router();

// GET all employees with position and department names
router.get('/', async (req, res) => {
  try {
    const { search, page = 1, limit = 20 } = req.query;
    const connection = await getConnection();
    
    let whereClause = 'WHERE e.is_deleted = 0 \n';
    let queryParams = [];
    
    if (search) {
      whereClause += `AND e.emp_name LIKE ?`;
      queryParams.push(`%${search}%`);
    }
    
    const offset = (page - 1) * limit;
    
    // Get employees with pagination
    const employeeQuery = `
      SELECT 
        e.id,
        e.emp_name,
        p.position_name,
        d.dept_name,
        division.div_name,
        e.is_register
      FROM employee e
      LEFT JOIN position p ON e.position_id = p.id
      LEFT JOIN dept d ON e.dept_id = d.id
      LEFT JOIN division ON d.div_id = division.id
      ${whereClause}
      ORDER BY e.id
      LIMIT ? OFFSET ?
    `;
    
    // Add limit and offset to params
    const employeeParams = [...queryParams, parseInt(limit).toString(), parseInt(offset).toString()];
    
    const [rows] = await connection.execute(employeeQuery, employeeParams);
    
    // Get total count for pagination
    const countQuery = `
      SELECT COUNT(*) as total
      FROM employee e
      LEFT JOIN position p ON e.position_id = p.id
      LEFT JOIN dept d ON e.dept_id = d.id
      LEFT JOIN division ON d.div_id = division.id
      ${whereClause}
    `;
    
    const [countResult] = await connection.execute(countQuery, queryParams);
    
    await connection.end();

    const totalPages = Math.ceil(countResult[0].total / limit);
    
    res.json({
      employees: rows,
      total: countResult[0].total,
      page: totalPages > 0 ? parseInt(page) : 0,
      limit: parseInt(limit),
      totalPages: totalPages
    });
  } catch (error) {
    console.log('Database error:', error.message);
    res.status(500).json({ error: error.message });
  }
});

// GET positions for dropdown
router.get('/positions', async (req, res) => {
  try {
    const connection = await getConnection();
    const [rows] = await connection.execute('SELECT * FROM position ORDER BY position_name');
    await connection.end();
    res.json(rows);
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

// GET departments for dropdown
router.get('/departments', async (req, res) => {
  try {
    const connection = await getConnection();
    const [rows] = await connection.execute('SELECT * FROM dept ORDER BY dept_name');
    await connection.end();
    res.json(rows);
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

router.get('/divisions', async (req, res) => {
  try {
    const connection = await getConnection();
    const [rows] = await connection.execute('SELECT * FROM division ORDER BY div_name');
    await connection.end();
    res.json(rows);
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

// POST create new employee
router.post('/', async (req, res) => {
  try {
    const { emp_name, position_id, dept_id } = req.body;
    const connection = await getConnection();
    
    const [result] = await connection.execute(
      'INSERT INTO employee (emp_name, position_id, dept_id) VALUES (?, ?, ?)',
      [emp_name, position_id, dept_id]
    );
    
    await connection.end();
    res.json({ success: true, id: result.insertId });
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

// PUT update employee
router.put('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { emp_name, position_id, dept_id } = req.body;
    const connection = await getConnection();
    
    await connection.execute(
      'UPDATE employee SET emp_name = ?, position_id = ?, dept_id = ? WHERE id = ?',
      [emp_name, position_id, dept_id, id]
    );
    
    await connection.end();
    res.json({ success: true });
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

// GET single employee for edit
router.get('/single/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const connection = await getConnection();
    
    const [rows] = await connection.execute(
      'SELECT * FROM employee WHERE id = ? AND is_deleted = 0',
      [id]
    );
    
    await connection.end();
    
    if (rows.length === 0) {
      return res.status(404).json({ error: 'Employee not found' });
    }
    
    res.json(rows[0]);
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const connection = await getConnection();
    
    await connection.execute(
      'UPDATE employee SET is_deleted = 1 WHERE id = ?',
      [id]
    );
    
    await connection.end();
    res.json({ success: true });
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

router.delete('/:id/force', async (req, res) => {
  try {
    const { id } = req.params;
    const connection = await getConnection();
    
    await connection.execute(
      'DELETE FROM employee WHERE id = ?',
      [id]
    );
    
    await connection.end();
    res.json({ success: true });
  } catch (error) {
    console.log(error.message);
    res.status(500).json({ error: error.message });
  }
});

// ==================== REUSABLE IMPORT FUNCTIONS ====================

/**
 * Find the header row and map column indices based on content
 */
const detectColumnIndices = (excelData) => {
  // Find the header row that contains "ลำดับ" in the first column
  let headerRowIndex = -1;
  let headerRow = null;
  
  for (let i = 0; i < excelData.length; i++) {
    const row = excelData[i];
    if (!row || row.length === 0) continue;
    
    const firstCell = row[0]?.toString().trim();
    if (firstCell === "ลำดับ") {
      headerRowIndex = i;
      headerRow = row;
      break;
    }
  }
  
  if (headerRowIndex === -1) {
    throw new Error('Header row with "ลำดับ" not found in Excel file');
  }
  
  console.log(`Found header row at index: ${headerRowIndex}`);
  
  // Find column indices based on header content
  const columnMap = {
    seqIndex: 0, // "ลำดับ" column is always index 0
    empNameIndex: null,
    positionIndex: null,
    divisionIndex: null,
    deptIndex: null
  };
  
  // Scan through header row to find column positions
  for (let colIndex = 0; colIndex < headerRow.length; colIndex++) {
    const cellValue = headerRow[colIndex]?.toString().trim();
    if (!cellValue) continue;
    
    const lowerValue = cellValue.toLowerCase();
    if (lowerValue.startsWith("ชื่อ")) {
      columnMap.empNameIndex = colIndex;
    }
    if (lowerValue.startsWith("ตำแหน่ง")) {
      columnMap.positionIndex = colIndex;
    }
    if (lowerValue.startsWith("สายงาน")) {
      columnMap.divisionIndex = colIndex;
    }
    if (lowerValue.startsWith("สำนัก") || lowerValue.startsWith("สังกัด")) {
      columnMap.deptIndex = colIndex;
    }
  }
  
  // Validate that all required columns were found
  const missingColumns = [];
  if (columnMap.empNameIndex === null) missingColumns.push('"ชื่อ"');
  if (columnMap.positionIndex === null) missingColumns.push('"ตำแหน่ง"');
  if (columnMap.divisionIndex === null) missingColumns.push('"สายงาน"');
  if (columnMap.deptIndex === null) missingColumns.push('"สำนัก"');
  
  if (missingColumns.length > 0) {
    throw new Error(`Missing required columns in header row: ${missingColumns.join(', ')}`);
  }
  
  console.log('Detected column indices:', columnMap);
  return {
    headerRowIndex,
    columnMap,
    dataStartIndex: headerRowIndex + 1 // Data starts right after header
  };
};

/**
 * Safely extract cell value
 */
const getCellValue = (cell) => {
  if (cell == null || cell === '') {
    return '';
  }
  return String(cell).trim();
};

/**
 * Parse and validate Excel row data with auto-add missing data
 */
const parseExcelRow = async (row, rowNumber, divisions, departments, positions, columnMap, connection, testing = false) => {
  // Check if row is empty
  if (!row || row.length === 0 || row.every(cell => cell == null || cell === '')) {
    return { skipped: true, reason: 'Empty row' };
  }
  
  // Safely get column indices
  const divisionIndex = columnMap?.divisionIndex ?? -1;
  const deptIndex = columnMap?.deptIndex ?? -1;
  const empNameIndex = columnMap?.empNameIndex ?? -1;
  const positionIndex = columnMap?.positionIndex ?? -1;
  
  // Extract values
  const divisionStr = divisionIndex >= 0 && row[divisionIndex] != null 
    ? getCellValue(row[divisionIndex]) 
    : '';
  
  const deptStr = deptIndex >= 0 && row[deptIndex] != null 
    ? getCellValue(row[deptIndex]) 
    : '';
  
  const empName = empNameIndex >= 0 && row[empNameIndex] != null 
    ? getCellValue(row[empNameIndex]) 
    : '';
  
  const positionStr = positionIndex >= 0 && row[positionIndex] != null 
    ? getCellValue(row[positionIndex]) 
    : '';
  
  // Validate required fields
  const missingFields = [];
  if (!empName) missingFields.push('Employee name');
  if (!divisionStr) missingFields.push('Division');
  if (!deptStr) missingFields.push('Department');
  if (!positionStr) missingFields.push('Position');
  
  if (missingFields.length > 0) {
    return { 
      error: `Row ${rowNumber}: Missing required fields: ${missingFields.join(', ')}` 
    };
  }
  
  // Find or add division
  let division = divisions.find(div => 
    div.div_name.toLowerCase() === divisionStr.toLowerCase()
  );
  
  // Auto-add missing division
  if (!division) {
    if (!testing) {
      const [result] = await connection.execute(
        'INSERT INTO division (div_name) VALUES (?)',
        [divisionStr]
      );
      division = { id: result.insertId, div_name: divisionStr };
      divisions.push(division);
      console.log(`Row ${rowNumber}: Added new division: ${divisionStr}`);
    } else {
      return { 
        error: `Row ${rowNumber}: | ไม่พบสายงานชื่อ "${divisionStr}" |` 
      };
    }
  }
  
  // Find or add department
  let department = departments.find(dept => 
    dept.dept_name.toLowerCase() === deptStr.toLowerCase() && 
    dept.div_id == division.id
  );
  
  // Auto-add missing department
  if (!department) {
    if (!testing) {
      const [result] = await connection.execute(
        'INSERT INTO dept (dept_name, div_id) VALUES (?, ?)',
        [deptStr, division.id]
      );
      department = { id: result.insertId, dept_name: deptStr, div_id: division.id };
      departments.push(department);
      console.log(`Row ${rowNumber}: Added new department: ${deptStr} in division: ${divisionStr}`);
    } else {
      return { 
        error: `Row ${rowNumber}: | ไม่พบสังกัดชื่อ "${deptStr}" ในสายงาน "${divisionStr}" |` 
      };
    }
  }
  
  // Find or add position
  let position = positions.find(pos => 
    pos.position_name.toLowerCase() === positionStr.toLowerCase()
  );
  
  // Auto-add missing position
  if (!position) {
    if (!testing) {
      const [result] = await connection.execute(
        'INSERT INTO `position` (position_name) VALUES (?)',
        [positionStr]
      );
      position = { id: result.insertId, position_name: positionStr };
      positions.push(position);
      console.log(`Row ${rowNumber}: Added new position: ${positionStr}`);
    } else {
      return { 
        error: `Row ${rowNumber}: | ไม่พบตำแหน่งชื่อ "${positionStr}" |` 
      };
    }
  }
  
  return {
    success: true,
    data: {
      emp_name: empName,
      division_id: division.id,
      division_name: division.div_name,
      dept_id: department.id,
      dept_name: department.dept_name,
      position_id: position.id,
      position_name: position.position_name,
      rowNumber
    }
  };
};

/**
 * Process Excel data rows with auto-add missing data
 */
const processExcelImport = async (excelData, connection, testing = false) => {
  // Load existing data
  const [divisions, departments, positions] = await Promise.all([
    connection.execute('SELECT * FROM division').then(([rows]) => rows),
    connection.execute('SELECT * FROM dept').then(([rows]) => rows),
    connection.execute('SELECT * FROM position').then(([rows]) => rows)
  ]);
  
  const savedEmployees = [];
  const errors = [];
  const addedRecords = {
    divisions: [],
    departments: [],
    positions: []
  };

  try {
    // Detect column indices
    const { headerRowIndex, columnMap, dataStartIndex } = detectColumnIndices(excelData);
    
    // Get data rows
    const dataRows = excelData.slice(dataStartIndex);
    
    console.log(`Processing ${dataRows.length} rows, Testing: ${testing}`);
    
    for (let index = 0; index < dataRows.length; index++) {
      const row = dataRows[index];
      const rowNumber = dataStartIndex + index + 1;
      
      // Parse and validate row with auto-add
      const validation = await parseExcelRow(
        row, rowNumber, divisions, departments, positions, 
        columnMap, connection, testing
      );
      
      if (validation.skipped) {
        continue;
      }

      if (validation.error) {
        errors.push(validation.error);
        continue;
      }
      
      const { emp_name: empName, dept_id, position_id } = validation.data;
      
      try {
        // Check for existing employee
        if (!testing) {
          const [existingEmployees] = await connection.execute(
            'SELECT id FROM employee WHERE emp_name = ? AND is_deleted = 0',
            [empName]
          );
          
          if (existingEmployees.length > 0) {
            errors.push(`Row ${rowNumber}: Employee "${empName}" already exists`);
            continue;
          }
        }
        
        // Insert employee if not testing
        if (!testing) {
          const [insertResult] = await connection.execute(
            'INSERT INTO employee (emp_name, position_id, dept_id, is_register) VALUES (?, ?, ?, 0)',
            [empName, position_id, dept_id]
          );
          
          const savedEmployee = {
            ...validation.data,
            id: insertResult.insertId,
            status: 'SAVED'
          };
          
          savedEmployees.push(savedEmployee);
        } else {
          // In testing mode, return validation result
          const testEmployee = {
            ...validation.data,
            status: 'VALIDATED'
          };
          savedEmployees.push(testEmployee);
        }
        
      } catch (dbError) {
        errors.push(`Row ${rowNumber}: Database error - ${dbError.message}`);
      }
    }
    
    return {
      saved: savedEmployees,
      errors,
      totalRows: dataRows.length,
      savedCount: savedEmployees.length,
      errorCount: errors.length,
      testingMode: testing
    };
    
  } catch (detectionError) {
    console.log('Error:', detectionError.message);
    return {
      saved: [],
      errors: [detectionError.message],
      totalRows: 0,
      savedCount: 0,
      errorCount: 1,
      testingMode: testing
    };
  }
};

// ==================== EXCEL IMPORT ROUTES ====================

// POST test Excel import (with auto-add simulation)
router.post('/test-import', async (req, res) => {
  console.log('=== EXCEL IMPORT TEST START ===');
  
  const connection = await getConnection();
  
  try {
    const { excelData } = req.body;
    console.log('Raw Excel Data Received (first 5 rows):', excelData?.slice(0, 5));
    
    if (!excelData || !Array.isArray(excelData)) {
      return res.json({ success: false, error: 'Invalid Excel data format' });
    }
    
    // In test mode (testing = true), it will show what would be added
    const result = await processExcelImport(excelData, connection, true);
    
    console.log('=== EXCEL IMPORT TEST SUMMARY ===');
    console.log('Total Rows Processed:', result.totalRows);
    console.log('Validated Rows:', result.savedCount);
    console.log('Error Rows:', result.errorCount);
    console.log('First 5 Results:', result.saved.slice(0, 5));
    console.log('First 5 Errors:', result.errors.slice(0, 5));
    console.log('=== EXCEL IMPORT TEST END ===\n');
    
    res.json({
      success: true,
      ...result,
      message: 'This is a test. No data was actually saved. Errors show what would fail without auto-add.'
    });
    
  } catch (error) {
    console.log('BACKEND ERROR:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  } finally {
    await connection.end();
  }
});

// POST real Excel import (save to database with auto-add)
router.post('/import', async (req, res) => {
  console.log('=== EXCEL IMPORT START (SAVING TO DATABASE WITH AUTO-ADD) ===');
  
  const connection = await getConnection();
  
  try {
    const { excelData } = req.body;
    
    if (!excelData || !Array.isArray(excelData)) {
      throw new Error('Invalid Excel data format');
    }
    
    await connection.beginTransaction();
    const result = await processExcelImport(excelData, connection, false); // testing = false
    
    await connection.commit();
    
    console.log('=== EXCEL IMPORT COMPLETE ===');
    console.log('Total Rows Processed:', result.totalRows);
    console.log('Successfully Saved:', result.savedCount);
    console.log('Errors:', result.errorCount);
    console.log('=== EXCEL IMPORT END ===\n');
    
    res.json({
      success: true,
      ...result,
      message: 'Import completed. Missing divisions, departments, and positions were automatically added.'
    });
    
  } catch (error) {
    await connection.rollback();
    console.log('IMPORT ERROR:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  } finally {
    await connection.end();
  }
});

// POST batch import with auto-add
router.post('/import-batch', async (req, res) => {
  const { excelData, batchSize = 100 } = req.body;
  
  if (!excelData || !Array.isArray(excelData)) {
    return res.status(400).json({ success: false, error: 'Invalid Excel data format' });
  }
  
  console.log(`Starting batch import with batch size: ${batchSize}`);
  
  const connection = await getConnection();
  const results = { 
    saved: [], 
    errors: [], 
    batches: [],
    addedRecords: {
      divisions: [],
      departments: [],
      positions: []
    }
  };
  
  try {
    await connection.beginTransaction();
    
    // Detect column indices once for the entire file
    const { headerRowIndex, columnMap, dataStartIndex } = detectColumnIndices(excelData);
    
    // Get all data rows
    const allDataRows = excelData.slice(dataStartIndex);
    const totalBatches = Math.ceil(allDataRows.length / batchSize);
    
    // Load existing data once for the entire batch process
    const [divisions, departments, positions] = await Promise.all([
      connection.execute('SELECT * FROM division').then(([rows]) => rows),
      connection.execute('SELECT * FROM dept').then(([rows]) => rows),
      connection.execute('SELECT * FROM position').then(([rows]) => rows)
    ]);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const start = batchIndex * batchSize;
      const end = start + batchSize;
      const batchRows = allDataRows.slice(start, end);
      
      console.log(`Processing batch ${batchIndex + 1}/${totalBatches} (rows ${start + 1} to ${Math.min(end, allDataRows.length)})`);
      
      const batchSaved = [];
      const batchErrors = [];
      
      for (let rowIndex = 0; rowIndex < batchRows.length; rowIndex++) {
        const row = batchRows[rowIndex];
        const globalRowIndex = start + rowIndex;
        const rowNumber = dataStartIndex + globalRowIndex + 1;
        
        try {
          // Parse and validate row with auto-add
          const validation = await parseExcelRow(
            row, rowNumber, divisions, departments, positions, 
            columnMap, connection, false // testing = false for real import
          );
          
          if (validation.skipped) {
            continue;
          }

          if (validation.error) {
            batchErrors.push(validation.error);
            continue;
          }
          
          const { emp_name: empName, dept_id, position_id } = validation.data;
          
          // Check for existing employee
          const [existingEmployees] = await connection.execute(
            'SELECT id FROM employee WHERE emp_name = ? AND is_deleted = 0',
            [empName]
          );
          
          if (existingEmployees.length > 0) {
            batchErrors.push(`Row ${rowNumber}: Employee "${empName}" already exists`);
            continue;
          }
          
          // Insert employee
          const [insertResult] = await connection.execute(
            'INSERT INTO employee (emp_name, position_id, dept_id, is_register) VALUES (?, ?, ?, 0)',
            [empName, position_id, dept_id]
          );
          
          const savedEmployee = {
            ...validation.data,
            id: insertResult.insertId,
            status: 'SAVED'
          };
          
          batchSaved.push(savedEmployee);
          
        } catch (dbError) {
          batchErrors.push(`Row ${rowNumber}: Database error - ${dbError.message}`);
        }
      }
      
      results.saved.push(...batchSaved);
      results.errors.push(...batchErrors);
      results.batches.push({
        batch: batchIndex + 1,
        startRow: start + 1,
        endRow: Math.min(end, allDataRows.length),
        saved: batchSaved.length,
        errors: batchErrors.length
      });
      
      // Optional: Commit each batch individually for better memory management
      // await connection.commit();
      // await connection.beginTransaction();
    }
    
    await connection.commit();
    
    console.log('=== BATCH IMPORT COMPLETE ===');
    console.log('Total Rows Processed:', allDataRows.length);
    console.log('Total Saved:', results.saved.length);
    console.log('Total Errors:', results.errors.length);
    console.log('Number of Batches:', results.batches.length);
    
    res.json({
      success: true,
      totalRows: allDataRows.length,
      totalSaved: results.saved.length,
      totalErrors: results.errors.length,
      batches: results.batches,
      saved: results.saved,
      errors: results.errors,
      message: 'Batch import completed with auto-add functionality.'
    });
    
  } catch (error) {
    await connection.rollback();
    console.log('BATCH IMPORT ERROR:', error.message);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  } finally {
    await connection.end();
  }
});

module.exports = router;